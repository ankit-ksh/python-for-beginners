# Getting Started with Python
Welcome to Python! This guide introduces you to the basics of Python programming: its syntax, data types, operators, and how to write and run simple programs. By the end, you’ll be ready to write your own Python scripts.

## 1. Introduction to Python

Before we dive into syntax, let’s set the stage: what a program is, how Python runs it, and the two common ways you’ll execute code.

### 1.1 Programs, languages, and how Python runs

- A program is an ordered set of instructions the computer executes to perform a task.
- Computers ultimately understand machine code (0s and 1s). Writing in raw machine code is impractical for humans, so we use high‑level programming languages (like Python) that are easier to read and write.
- High‑level code (source code) must be translated for the computer. Two common translators:
  - Interpreter: reads your program statement by statement, translating and executing each step until it finishes or hits an error.
  - Compiler: translates the whole program to a separate machine‑readable file (object/binary) and reports errors after a full scan.
- Python uses an interpreter, so feedback is immediate and great for iteration and learning.

### 1.2 Features of Python (at a glance)

- High‑level, free, and open‑source.
- Interpreted and interactive: perfect for quick experiments in a REPL.
- Clear, readable syntax; indentation defines code blocks.
- Case‑sensitive identifiers (`total` and `Total` are different).
- Portable across operating systems; “batteries included” standard library plus a huge ecosystem (web, data, automation, scripting, and more).

Tip: Install from the official site if needed — https://www.python.org/

### 1.3 Working with Python (the interpreter / shell)

Python’s interactive prompt is called the shell or REPL (Read–Eval–Print Loop). You type an expression, Python evaluates it, and prints the result.

Try it (interactive):

```py
>>> 2 + 3
5
>>> print("Hello")
Hello
```

Use the interactive prompt to test small snippets and explore functions quickly.

### 1.4 Execution modes: interactive vs script

There are two primary ways to run Python code:

1) Interactive mode (REPL)
	- Enter single lines at the `>>>` prompt.
	- Immediate feedback; great for learning and quick checks.
	- Not ideal for saving or sharing multi‑line programs.

2) Script mode (files ending with `.py`)
	- Write multiple statements in a file and run them together.
	- Saves your work, can be versioned and shared.

Try it (script mode): create a file `hello.py` with:

```py
print("Hello from a script!")
```

Then run it from a terminal (Linux/macOS, zsh):

```sh
python3 hello.py
```

A tiny example program in script mode (print in action):

```py
# demo_print.py
message = "Python is fun"
print(message)
```

Run and you should see:

```
Python is fun
```

## 2. Keywords

Keywords are reserved words that have a special meaning in Python. You cannot use them as identifiers (variable or function names). Examples: `if`, `else`, `for`, `while`, `def`, `return`, `class`, `import`, `in`, `and`, `or`, `not`, `True`, `False`, `None`.

Quick tip: To see the full list in an interactive session run:

```py
import keyword
print(keyword.kwlist)
```

---

## 3. Identifiers (naming variables, functions, classes)

An identifier is the name you give to variables, functions, classes, modules, etc. Rules and conventions:
- Must start with a letter (a–z, A–Z) or underscore `_` and can contain letters, digits and underscores. Example: `total`, `_count`, `user2`.
- Case-sensitive: `data` and `Data` are different.
- By convention: use snake_case for variables and functions (`my_variable`), PascalCase for classes (`MyClass`).
- Avoid using keywords or names that shadow built-ins (for example `list`, `str`, `id`).

Example:

```py
temperature_c = 25  # good
List = []            # confusing: looks like built-in 'list'
```

<Questions>
	<ol>
		<li>Which of these identifiers are invalid in Python and why? <code>Serial_no.</code>, <code>1st_Room</code>, <code>Hundred$</code>, <code>Total Marks</code>, <code>Total_Marks</code>, <code>total-Marks</code>, <code>_Percentage</code>, <code>True</code></li>
	</ol>
</Questions>

---

## 4. Comments

Comments explain code for humans and are ignored by the interpreter.
- Single-line comment: start with `#`.
- Multi-line comment/documentation: use triple quotes (`""" ... """`) for docstrings inside functions/classes.

Examples:

```py
# This is a single-line comment
def add(a, b):
	"""Return the sum of a and b."""
	return a + b
```

Editor tip: most editors toggle comments with Ctrl+/ (or Cmd+/ on macOS).

---

## 5. Variables

Variables are names that refer to objects (values) in memory. In Python:
- A variable is created when you first assign to it.
- You must assign before use, otherwise you’ll get a NameError.
- Strings go in quotes; numbers do not.
- Reassignment simply binds the name to a new value.

Examples:

```py
message = "Keep Smiling"   # string
print(message)

user_no = 101               # integer
print('User Number is', user_no)

length = 10
breadth = 20
area = length * breadth
print(area)                 # 200
```

Quick tips
- Use clear, snake_case names (e.g., total_marks, price_per_item).
- Don’t rely on implicit types; check with type(value) when in doubt.
- Avoid reusing names like list, dict, str (they shadow built-ins).

<Questions>
	<ol>
		<li>Assign 10 to <code>length</code> and 20 to <code>breadth</code>.</li>
		<li>Assign the average of <code>length</code> and <code>breadth</code> to <code>sum</code>.</li>
	</ol>
</Questions>

## 6. Data types

Python has several built-in data types. The most common ones:
- Integers (`int`) — whole numbers: 0, -3, 42.
- Floating point (`float`) — decimal numbers: 3.14, -0.5.
- Strings (`str`) — text: "hello", 'world'.
- Boolean (`bool`) — `True` or `False`.
- Lists, tuples, sets, dictionaries — collections (covered later).

Python is dynamically typed: the type is associated with the value, not the variable name.

Example:

```py
age = 30          # int
price = 9.99      # float
name = "Asha"    # str
is_active = True  # bool
```

Check type with `type()`:

```py
print(type(age))   # <class 'int'>
```

### Note: everything is an object (identity)

- Every value in Python is an object and has a unique identity for its lifetime; see it with `id()`.

```py
num1 = 20
num2 = 30 - 10
print(id(num1) == id(num2))  # often True (both refer to 20)
```

### Numeric types (extra)

- `complex` numbers are built-in: `3 + 4j` (real + imag).
- `bool` is a subtype of `int`: `True == 1`, `False == 0`.

```py
z = 3 + 4j
print(type(z))      # <class 'complex'>
print(True + 2)     # 3
```

### Mutable vs immutable (quick)

- Immutable: `int`, `float`, `bool`, `str`, `tuple` — value can’t be changed; reassigning binds the name to a new object.
- Mutable: `list`, `dict`, `set` — can change contents in place.

```py
a = 300
b = a
a = b + 100
# a now refers to a new object; b still refers to 300
```

### Choosing a collection (quick guide)

- List: ordered, mutable — use for sequences you’ll update often.
- Tuple: ordered, immutable — use for fixed-size records (e.g., coordinates).
- Set: unordered, unique elements — use to remove duplicates or test membership fast.
- Dict: key → value mapping — use for fast lookups by key (e.g., phonebook).

### Examples: common built-in data types

Numbers (`int`, `float`)

```py
# Integers are unbounded
big = 10**50
print(type(big), big)

# Floats are IEEE 754 doubles
pi = 3.14159
radius = 2.5
area = pi * (radius ** 2)
print(area)  # 19.6349375

# Division operators
print(5 / 2)   # 2.5  (true division)
print(5 // 2)  # 2    (floor division)
print(5 % 2)   # 1    (remainder)
```

Boolean (`bool`)

```py
is_open = True
is_admin = False
print(is_open and is_admin)  # False
print(is_open or is_admin)   # True
print(not is_open)           # False

# Truthiness: non-zero numbers, non-empty containers are True; 0, '', [], {}, set() are False
print(bool(0), bool(1), bool(""), bool("hi"))  # False True False True
```

Strings (`str`)

```py
name = "Asha"
greeting = f"Hello, {name}!"
print(greeting)  # Hello, Asha!

# Indexing and slicing
text = "python"
print(text[0], text[-1])   # p n
print(text[1:4])           # yth

# Common methods
print("  spaced  ".strip())       # 'spaced'
print("mixed Case".lower())       # 'mixed case'
print("a,b,c".split(","))        # ['a', 'b', 'c']
```

Lists (`list`)

```py
nums = [1, 2, 3]
nums.append(4)
nums[0] = 10
print(nums)           # [10, 2, 3, 4]
print(nums[:2])       # [10, 2]

# List comprehension
squares = [n*n for n in nums]
print(squares)        # [100, 4, 9, 16]
```

Tuples (`tuple`)

```py
point = (3, 4)
x, y = point  # unpacking
print(x, y)   # 3 4

# Tuples are immutable: the following would raise an error
# point[0] = 5  # TypeError
```

Dictionaries (`dict`)

```py
user = {"name": "Asha", "age": 30}
print(user["name"])               # Asha
user["city"] = "Nairobi"          # add a key
user["age"] += 1                   # update
print(user.get("country", "N/A"))  # safe lookup with default

for key, value in user.items():
	print(key, value)
```

Sets (`set`)

```py
items = {1, 2, 2, 3}
print(items)                 # {1, 2, 3}  (duplicates removed)

items.add(4)
items.discard(2)
print(3 in items)            # True

a = {1, 2, 3}
b = {3, 4}
print(a | b)   # union -> {1, 2, 3, 4}
print(a & b)   # intersection -> {3}
print(a - b)   # difference -> {1, 2}
```

`None` (the absence of a value)

```py
result = None
if result is None:
	print("No result yet")

# Prefer `is`/`is not` when comparing with None
value = 0
print(value == None)   # False (but avoid this style)
print(value is None)   # False (preferred style for None checks)
```

---
<Questions>
	<ol>
		<li>Choose the most suitable data type (and why) for each: number of months in a year, resident of Delhi or not, mobile number, pocket money, volume of a sphere, perimeter of a square, name of the student, address of the student.</li>
	</ol>
</Questions>

## 7. Operators

Operators act on values (operands) to compute results, e.g., in `10 + n`, `10` and `n` are operands; `+` is the operator.

### 7.1 Arithmetic

- `+` add, `-` subtract, `*` multiply, `/` true division
- `//` floor division, `%` remainder, `**` exponent

```py
5 / 2   # 2.5
5 // 2  # 2
5 % 2   # 1
2 ** 3  # 8

"Hello" + "India"   # 'HelloIndia' (string concatenation)
"Hi" * 3            # 'HiHiHi' (string repetition)
```

### 7.2 Comparison (relational)

- `==`, `!=`, `<`, `>`, `<=`, `>=` — all return booleans.
- Strings compare lexicographically (by Unicode code points) and are case-sensitive.

```py
10 < 12        # True
"apple" < "banana"  # True
"a" < "Z"      # False (because 'a' > 'Z')
```

### 7.3 Assignment

- `=` assign; augmented assignment updates in place when possible:
	- `+=`, `-=`, `*=`, `/=`, `%=`, `//=`, `**=`

```py
x = 10
x += 2     # 12
name = "Hello"
name += "India"  # 'HelloIndia'
country = "IN"
country *= 3      # 'INININ'
```

### 7.4 Logical

- `and`, `or`, `not` combine boolean expressions; any non-empty/non-zero is truthy.

```py
True and False   # False
0 or 42          # 42 (truthy)
not ""           # True
```

### 7.5 Identity

- `is` / `is not` check object identity (same object), not equality of values.
- Prefer `is`/`is not` for `None` checks.

```py
a = [1,2]; b = [1,2]
a == b      # True (same contents)
a is b      # False (different objects)
val = None
val is None     # True
```

### 7.6 Membership

- `in`, `not in` test for containment in sequences/sets/dicts (dict checks keys).

```py
a = [1,2,3]
2 in a          # True
"py" in "python"  # True
"name" in {"name": "Asha"}  # True (checks keys)
```

Operator precedence (brief): parentheses `()` first, then exponentiation, then multiplication/division/modulo, then addition/subtraction, then comparisons, then logical operators. Use parentheses to make intent explicit.

---

<!-- Inline question and inline example removed as requested -->


<Questions>
	<ol>
		<li>Evaluate mentally: <code>7 + 3 * 4</code>. Which part runs first?</li>
		<li>What is the value of <code>"py" in "python"</code>? Why?</li>
		<li>Is <code>a is b</code> the same as <code>a == b</code>? Explain briefly.</li>
		<li>Given <code>x = 0</code>, what is the result of <code>(x or 5) and 10</code>?</li>
		<li>
			Write Python expressions for each and evaluate (assume <code>num1</code>, <code>num2</code>, <code>num3</code>, <code>first</code>, <code>middle</code>, <code>last</code> exist):
			<ul>
				<li>The sum of 20 and −10 is less than 12.</li>
				<li><code>num3</code> is not more than 24.</li>
				<li>6.75 is between <code>num1</code> and <code>num2</code>.</li>
				<li>The string 'middle' is larger than 'first' and smaller than 'last'.</li>
			</ul>
		</li>
	</ol>
</Questions>

## 8. Expressions and statements

An expression combines constants, variables, and operators and always evaluates to a value. A single literal or variable is also an expression; a standalone operator is not.

Examples of expressions

```py
100
num
num - 20.4
3.0 + 3.14
23/3 - 5 * 7 * (14 - 2)
"Global" + "Citizen"
```

### 8.1 Precedence and associativity (quick guide)

- Order (simplified): parentheses `()`, exponent `**`, multiply/divide/mod/floor, add/subtract, comparisons, logical `not`, `and`, `or`.
- Unary operators apply to one operand; exponent binds before unary minus: `-3**2` is `-(3**2)` → `-9`.
- Parentheses override precedence and improve readability. For equal precedence, evaluation is left to right (except `**`, which is right-associative).

Evaluate step by step

```py
20 + 30 * 40          # 20 + (30*40) -> 1220
20 - 30 + 40          # (20 - 30) + 40 -> 30
(20 + 30) * 40        # 2000
15.0 / 4 + (8 + 3.0)  # 3.75 + 11.0 -> 14.75
```

<Questions>
	<ol>
		<li>Make each expression evaluate to <code>True</code> by adding one pair of parentheses:
			<ul>
				<li><code>0 == 1 == 2</code></li>
				<li><code>2 + 3 == 4 + 5 == 7</code></li>
				<li><code>1 &lt; -1 == 3 &gt; 4</code></li>
			</ul>
		</li>
	</ol>
</Questions>

### 8.2 Statements

A statement is a unit of code Python can execute (assignment, import, `if`, `for`, `while`, `def`, etc.). Many statements contain expressions.

```py
x = 4                 # assignment statement
cube = x ** 3         # assignment with expression
print(x, cube)        # print statement
```

---


## 9. Input and output (I/O)

Basic output: use `print()` to display values.

```py
print("Hello, world!")
print("Sum:", 2 + 3)
```

Basic input: use `input()` to read from the user (returns a string).

```py
name = input("Enter your name: ")
print("Hi", name)
```

Remember: `input()` returns a string. Convert to numeric types when needed (see next section).

---

## 10. Type conversion (casting)

Convert between types using `int()`, `float()`, `str()`, `bool()`.

Example:

```py
age_str = input("Enter your age: ")
age = int(age_str)  # convert to int
```

Always validate or handle exceptions when converting user input. A quick pattern:

```py
try:
	age = int(input("Enter your age: "))
except ValueError:
	print("Please enter a valid integer.")
```

### 10.1 Why conversion matters (string vs number)

`input()` always returns a string. If you do arithmetic without converting, you may get string behavior instead of numeric behavior.

Example: doubling a number from input

```py
num = input("Enter a number and I'll double it: ")
print(num * 2)   # repeats the string
# If you type 2, this prints: 22

# Fix: convert to int (or float) before arithmetic
num = int(num)
print(num * 2)   # 4 when input is 2
```

Key idea: convert text to a numeric type before math; convert back to text for display when concatenating.

### 10.2 Explicit conversion (type casting)

Explicit conversion happens when you call a function to change a value's type.

Common functions
- `int(x)`: to integer. Truncates toward zero if `x` is a float; parses decimal strings like `"42"`.
- `float(x)`: to floating-point number. Parses strings like `"3.14"`, accepts `"inf"`, `"-inf"`, `"nan"`.
- `str(x)`: to string representation.
- `bool(x)`: to boolean using truthiness rules.
- `chr(i)`: code point (integer) -> one-character string.
- `ord(ch)`: one-character string -> code point (integer).

Notes and pitfalls
- `int(20.67)` becomes `20` (fraction is discarded).
- `int("20.67")` raises `ValueError`; use `float("20.67")` first, then optionally `int()`.
- When joining text, prefer `f"...{value}..."` or `str(value)` over raw concatenation with numbers.

Examples

```py
# int to float
a, b = 10, 20
s = a + b
print(s, type(s))            # 30 <class 'int'>
sf = float(a + b)
print(sf, type(sf))          # 30.0 <class 'float'>

# float to int (truncation)
x, y = 10.2, 20.6
t = x + y
print(t, type(t))            # 30.8 <class 'float'>
ti = int(x + y)
print(ti, type(ti))          # 30 <class 'int'>

# numbers <-> strings
price_icecream = 25
price_brownie = 45
total = price_icecream + price_brownie

# print("Total Rs." + total)  # TypeError: can't concat str and int
print("Total Rs." + str(total))           # explicit cast
print(f"Total Rs.{total}")                 # f-string (recommended)

# strings to numbers
icecream, brownie = "25", "45"
print("Concat:", icecream + brownie)      # '2545' (concatenation)
print("Sum:", int(icecream) + int(brownie))

# chr/ord
print(chr(65))   # 'A'
print(ord('A'))  # 65
```

Robust user input pattern

```py
def read_int(prompt="Enter an integer: "):
	while True:
		s = input(prompt)
		try:
			return int(s)
		except ValueError:
			print("Please enter digits only (e.g., 42).")
```

### 10.3 Implicit conversion (coercion, type promotion)

Python promotes numeric types automatically in mixed arithmetic to preserve information.

Rules of thumb
- `int` + `float` -> `float`
- `int`/`float` + `complex` -> `complex`
- `bool` behaves like `int` (with values `1` and `0`).

Example

```py
num1 = 10       # int
num2 = 20.0     # float
sum1 = num1 + num2
print(sum1, type(sum1))  # 30.0 <class 'float'>

# bool in arithmetic
print(True + 2)          # 3
print(False * 10.0)      # 0.0
```

Why promote to float? Converting `float` to `int` would lose the fractional part; promoting `int` to `float` keeps precision for typical cases.

### 10.4 Common pitfalls and best practices

- String repetition vs multiplication: `"2" * 3` -> `'222'` (string repeat), not `6`.
- Converting empty strings: `int("")` and `float("")` raise `ValueError` — validate input.
- Boolean conversion of strings: any non-empty string is `True` — even `"False"`.
  - Prefer explicit checks like `s.lower() in {"true","t","1","yes","y"}`.
- Rounding: `int(2.9)` -> `2`; for rounding use `round(2.9)` -> `3` (banker’s rounding rules apply).
- Formatting numbers: for display, use `format()`/f-strings instead of manual concatenation.

```py
value = 1234.5678
print(f"{value:.2f}")        # 1234.57
print(f"{value:,.1f}")       # 1,234.6
```

### 10.5 Quick reference

- To int: `int(x)` or `int(s, base)` for strings like `"1010"` with a base (e.g., `int("1010", 2)` -> `10`).
- To float: `float(x)`, `float('inf')`, `float('nan')`.
- To str: `str(x)` or formatted f-strings `f"...{x}..."`.
- To bool: `bool(x)` uses truthiness (`0`, `0.0`, `''`, `[]`, `{}`, `set()`, `None` -> `False`; everything else -> `True`).
- Code points: `ord('A')` -> `65`, `chr(9731)` -> '☃'.

### 10.6 Mini exercises

1) Read a number from the user and safely print its square. If input is invalid, ask again.
2) Parse a binary string (e.g., `"1101"`) into an integer using `int(s, 2)`.
3) Given `values = ["10", "20.5", "x", "3"]`, convert each to `float` where possible, skipping invalid entries.
4) Ask for two numbers; print their sum as an integer if both are integers, otherwise as a float.

---

 

## 11. Debugging

When you write programs, mistakes happen. Debugging is the skill of finding and fixing them efficiently. Start by recognizing the kind of error you’re facing, then apply the right tool.
	Example — missing parenthesis
  
	```py
	# print("hi"  # SyntaxError: unmatched '('
	```

- **Logical errors**: The code runs but does the wrong thing. You won’t see an exception — only incorrect results.
  
	Example — wrong average due to precedence
  
	```py
	# average of 10 and 12 (WRONG)
	print(10 + 12 / 2)   # 16
  
	# correct: force the intended grouping with parentheses
	print((10 + 12) / 2) # 11.0
	```

- **Runtime errors (exceptions)**: The code is syntactically valid, but something goes wrong while it’s running (e.g., dividing by zero, converting invalid input).
  
	Example — invalid input and division by zero
  
	```py
	x = input("Enter a whole number: ")   # e.g., "abc" or "0"
	n = int(x)                             # ValueError if x is not digits
	print(10.0 / n)                        # ZeroDivisionError if n == 0
	```

	<Questions>
		<ol>
			<li>Categorise each as syntax, logical, or runtime error:
				<ul>
					<li><code>25 / 0</code></li>
					<li><code>num1 = 25; num2 = 0; num1/num2</code></li>
				</ul>
			</li>
		</ol>
	</Questions>

### 11.2 Read the traceback like a pro

When an exception happens, Python prints a “traceback” showing where it occurred.

```
Traceback (most recent call last):
	File "script.py", line 3, in <module>
		n = int("abc")
ValueError: invalid literal for int() with base 10: 'abc'
```

How to use it
- **Bottom line** = error type and message (what went wrong).
- **Lines above** = call stack (where it happened). Start from the topmost line in your code (ignore library internals at first).
- Note the file and line number; jump there and inspect variables.


### 11.3 Use the debugger

You can pause execution with `breakpoint()` and step through code, inspect variables, and evaluate expressions.

```py
def compute(x):
			otal = x * 2
			breakpoint()      # execution pauses here: inspect total, x
			return total + 1
```

Tips
- Place breakpoints just before a suspicious line.
- Step line-by-line and watch how variables change.
- Prefer a debugger for multi-step logic; use `print()` for quick checks.


## Exercises

Short practice to reinforce the basics. Tackle the quick ones first; larger programming problems follow.

### A) Output prediction and reasoning

1) What is printed? Explain briefly.

```py
num1 = 4
num2 = num1 + 1
num1 = 2
print(num1, num2)
```

2) What is printed? Explain the tuple assignment order.

```py
num1, num2 = 2, 6
num1, num2 = num2, num1 + 2
print(num1, num2)
```

3) Predict the output or the error raised:

```py
num1, num2 = 2, 3
num3, num2 = num1, num3 + 1
print(num1, num2, num3)
```

4) Assume initially: `num1 = 4`, `num2 = 3`, `num3 = 2`. Evaluate step-by-step:

```py
num1 += num2 + num3
print(num1)

num1 = num1 ** (num2 + num3)
print(num1)

num1 **= num2 + num3
num1 = '5' + '5'
print(num1)

print(4.00/(2.0+2.0))

num1 = 2+9*((3*12)-8)/10
print(num1)

num1 = 24 // 4 // 2
print(num1)

num1 = float(10)
print(num1)

num1 = int('3.14')
print(num1)

print('Bye' == 'BYE')
print(10 != 9 and 20 >= 20)
print(10 + 6 * 2 ** 2 != 9//4 -3 and 29 >= 29/9)
print(5 % 10 + 10 < 50 and 29 <= 29)
print((0 < 6) or (not(10 == 6) and (10<0)))
```

### B) Expressions and geometry

5) A dartboard has radius 10 and center at (0,0). Given dart coordinates `(x, y)`, write a Python expression that is `True` when the dart hits the board (is inside or on the circle). Then evaluate for:

- (0, 0)
- (10, 10)
- (6, 6)
- (7, 8)

### C) Small programs

6) Convert Celsius to Fahrenheit. Use your program to print the boiling and freezing points of water in °F.

7) Simple interest: Given principal `P`, rate `R` (% per annum), and time `T` (years), compute simple interest `SI = (P*R*T)/100` and amount `A = P + SI`.

8) Work together: If A, B, C take `x`, `y`, `z` days individually, compute days together using `xyz/(xy + yz + xz)`.

9) Enter two integers and print results of all arithmetic operators.

10) Swap two numbers using a third variable; then repeat without a third variable.

11) Repeat the string "GOOD MORNING" `n` times (read `n` from the user).

12) Read three numbers and print their average.

13) Volume of a sphere for radius 7, 12, 16 (`V = 4/3 * π * r**3`).

14) Ask the user for name and age; print the calendar year they will turn 100.

15) Energy from mass: Read mass `m` and compute energy `E = m * c**2` with `c = 3e8`.

16) Ladder height: Given ladder `length` and `angle` (degrees) to the ground, compute wall height reached (use `math.sin(math.radians(angle))`). Try:

- (16 ft, 75°)
- (20 ft, 0°)
- (24 ft, 45°)
- (24 ft, 80°)
